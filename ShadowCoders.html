<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowCoders</title>
    <style>
        #main
        {
            font-size: 200px;
            color: darkgray;
            background-color: black;
            font-family: cursive;
            text-shadow: 5px 5px 5px rgb(165, 7, 126);
            margin: 0%;
        }
        h1{
            color: blueviolet;
        }
        *{
            color: lightgray;
            font-family: cursive;
            background-color: black;
        }
        #process{
            box-sizing: border-box;

        }

    </style>
</head>
<body>
    <h1 id="main">Shadow Coders</h1>
    <a href="Algorithm.html">Design and Analysis of Algorithm</a><br>
    <a href="logic.html">Discrete Mathematics</a><a href=""></a><a href=""></a>
    <h1>Software</h1>
    <ul>Software is a collection of instructions that enable the user to interact with a computer ,its hardware or perform tasks</ul>
    <h2>What is software engineering</h2>
    <div>Software engineering is the detailed study of design ,development , maintainance of software Software engineering
        was introduced to address the issues of low-quality software projects.Problems arise when a software generally exceeds timelines, budgets,
        and reduced levels of quality.</div><br>
    <div>
        <b>Different types of software</b>
        <li>System software</li>
        <li>Applilcation Software</li>
        <li>Utility Software</li>
        <li>Device Drivers</li>
    </div>
    <a href="#">
        <h1>SDLC</h1>
    </a>
    <div>SDLC is a process used by the software industry to design, develop and
        test high quality software. The SDLC aims to produce a high-quality
        software that meets or exceeds customer expectations, reaches
        completion within times and cost estimates.</div>
    <div>
    <h2>Seven phases of Software Development Life Cycle</h2>
    <ol>
    <li><strong>Planning</strong></li>
    <li><strong>Requirment Elicitation</strong>
         <ul>SRS (software requirment specification)
             <ul>funtional requirment:- What a software system should do</ul>
             <ul>Non Functional Requirment:- Constraints on how the system will do so.</ul>
        </ul>
        <ul>Requirment Gathering Tools</ul>
        <ul><i>Feasiblity Study:- </i><br> objective of a software feasibility study, as the name implies, is to
            assess from the operational, technical, economic and organizational
            point of view whether the project is viable. 
            <ol>
            <li>Technical Feasiblity</li>
            <li>Economic Feasiblity</li>
            <li>Operational Feasiblity</li>
            <li>Schedule Feasiblity</li>
            <li>Legal and Ethical</li>
            </ol></ul>
    </li>
    <li><strong>Analysis</strong><br>Detailed study of various operation performed by system and their relationship within and outside the system
        <ul><b><i>ACD</i></b><br>Architectural Context Diagram is a graphic representation of your
            system and of the external components that interact with the system.
            This components are linked to the system via interfaces, illustred by a
            rectangle</ul></li>
    <li><strong>Design</strong></li>
    <li><strong>Development (Implementation and Testing of software)</strong></li>
    <li><strong>Deployment</strong></li>
    <li><strong>Maintenance and Reviews</strong></li>
    </ol>
    

    <a href="#">
        <h1>Cost Estimation Models</h1>
    </a>
    <h2>Effort Estimation Model</h2>
    <ol>
        <li><strong>Static, Single Variable Model</strong><ul><b>Eg: SEL ( SE
            laboratory)Model</b><br>
            E=1.4 L^0.93 : cost of producing software
            (a= 1.4, b=0.93)<br>
            
            D=4.6 L^0.26 ( c = 4.6, d =0.26) <br>
            
            Where E= Efforts (Person Per Month)
            D = Duration (chronological order of months)
            L = SLOC (in KLOC, how many lines of codes in thousands)</ul></li>
        <li><strong>Static, Multivariable Model</strong><ul><b>Eg: WALSTON and FELIX model</b><br>
            1. Effort ( E ): Cost spent for producing software
            E =5.2L0.91
            (a= 5.2, b=0.91) <br>
            
            2. Duration of development (D)
            D=4.1L0.36 <br></ul></li>
    </ol>
    <h2>COCOMOâ€™81 Model or COCOMO-I</h2>
    <ul>
        <li>Stands for Constructive Cost Model</li>
        <li>Used to calculate effort and duration of time required for a project</li>
        <li>Used to predict size, effort, cost, time and
            quality</li>
    </ul>
    <h2>Types of COCOMO Model</h2>
    <ol>
        <li>Basic COCOMO
            <ol>
                <li>Organicn Mode</li>
                <li>Semi Detached MOde</li>
                <li>Embedded Mode</li>
            </ol>
        </li>
        <li>Intermediate COCOMO
            <ol>
                <li>Organic Mode</li>
                <li>Semi Detached Mode</li>
                <li>Embedded Mode</li>
            </ol>
        </li>
        <li>Detailed COCOMO
            <ol>
                <li>Organic</li>
                <li>Semi Detached</li>
                <li>Embedded</li>
            </ol>
        </li>
    </ol>


<a href="#">
    <h1>Process Models</h1>
</a>
<h2><u>Process Flow</u></h2>
<p>Process flows (or process diagrams) provide a visual overview or workflow diagram of all the tasks and relationships involved in a process.</p>
<ul id="process">Components of Process Flow
    <li>Communication</li>
    <li>Planning</li>
    <li>Modeling</li>
    <li>Construction</li>
    <li>Deployment</li>
</ul>
<ol style="list-style-type: lower-alpha;">Types of Process Flow
    <li><strong>Linear Process Flow </strong><br>executes each of the five activities in the sequence <br>Ex: Waterfall Model</li>
    <li><strong>Iterative Process Flow</strong><br>repeat one or more of the activities before proceeding to the next <br>Ex: RAD Model, Agile Model</li>
    <li><strong>Evolutionary Process Flow</strong><br>executes the activities in a circular manner <br>Ex: Spiral Model, Prototype Model</li>
    <li><strong>Parallel Process Flow</strong><br>executes one or more activities in parallel with other activities <br>Ex: Time Boxing Model</li>
</ol>

<ol>Types of Process Models
    <li><strong>Big Bang Model</strong><ul>
        <li>used for small project with small teams</li>
        <li>may or maynot fullfill customer requirments</li>
        <li>easy to implement</li>
        <li>need little planning and few resources</li>
        <li>unsuitable for OO design</li>
    </ul></li>
    <li><strong>Code and Fix Model</strong></li>
    <li><strong>Waterfall Model</strong><ul>
        <li>oldest model known as the mother of all models</li>
        <li>also known as linear sequential model</li>
        <li>reinforce good habits of define before design and design before code  </li>
        <li>preferred in project where quality is more important than cost</li>
        <li>unsuitable for OO and big complex projecy</li>
    </ul></li>
    <li><strong>V Model</strong><ul>
        <li>extension of waterfall model</li>
        <li>It is called verificationo and validation model because here for each development activity there is a testing activity also.</li>
        <li>used for small projects where requirments are clear</li>
        <li>bad for complex project and OO</li>
        <li>non iterative model</li>
    </ul></li>
    <li><strong>RAD</strong></li>
    <li><strong>Agile Model</strong></li>
    <li><strong>Prototype Model</strong></li>
    <li><strong>Spiral Model</strong></li>
    <li><strong>Time Box Model</strong></li>
</ol>

<ol>
    <li><b>Smoke Testing</b><br>smoke testing not perform deep testing but it verifies that main functionality of code 
    are working fine .It tests the critical area but not the whole application <li>verifies stability</li>
    <li>done by programmers or testers</li></li>
    <li><b>Sanity testing</b>It is a surface level testing which verifies whether the software qualitu is good enough
    to pass it on the next level of testing <li>verifies rationality</li>
    <li>done by testers</li></li>
    <li><b>Regression Testing/System testing</b></li>
</ol>    
<table><tbody>
    <tr>
        <th>Regression Testing</th>
        <th>Retesting</th>
    </tr>
    <tr>
        <td>It is known as generic testing</td>
        <td>It is known as planned testing</td>
        <td>It is super set of smoke and sanity testing</td>
        <td>It is type of software testing used to check whether a code change has not unfavourly disturbed the current feature and
           funtion of software  </td>
    </tr>
    <tr>
        <td>It can be done with automation</td>
        <td>It can not be done with automation</td>
        <td>Testers find bugs and assign it to the developer and developer fix the bug and send it back to the testers
            for further verification . This continuous process is called retesting.
        </td>
    </tr>
</tbody></table>

<ol>Testing
    <li>Dynamic testing :  white box testing ie verification ie authorization ie how system will do
        <li>functional testing</li>
        <li>non functional testing</li>
    </li>
    <li>Static testing : black box testing ie validation ie authentication ie what system will do
        <li>review 
        <li>Informal reviews</li>
        <li>walkthrough</li>
        <li>technical review</li>
        <li>Inspection</li></li>
        <li>static anlysis 
        <li>Data flow testing</li>
        <li>Control testing</li>
        <li>cyclomatic complexity</li>
        </li>
    </li>
</ol>
<ol>Dynamic testing broad classification
    <li>White box testing
        <li>functional testing :they can be done manually<li>unit testing</li>
        <li>Integration testing</li>
        <li>system testing</li>
        <li>acceptance testing</li>
        </li>
        <li>non functional testing :They are hard to perform manually <li>recovery testing</li>
        <li>compatibility testing</li>
        <li>security testing</li>
        <li>performance testing</li>
    </li>
    <li>Black box testing
        <li>Data flow /control testing <li>unit testing</li>
        <li>integration testing</li></li>
    </li>
</ol>

<ol>Differnt peneteration techniques
    <li>Black box testing
        <li>zero knowledge</li>
        <li>Testing as attackers</li>
        <li>It involves testing from external/end user perspective</li>
        <li>it means validating ie authentication means what system will do</li>
    </li>
    <li>White box testing
        <li>Full knowledge</li>
        <li>Testing as developers</li>
        <li>It is a software technique in which inernal structure,design and code of software are tested to verify flow of 
            input and output and to enhance design ,usability and security.
        </li>
        <li>It means verification ie authorization means how system will do</li>
    </li>
    <li>Grey box testing
        <li>Some knowledge</li>
        <li>Testing as user have access to some data</li>
        <li>security realted ,GUI related ,database related,browser related and operational system related testing
            all are part of test cases designed for grey box testing
        </li>
    </li>
</ol>
<ol>
    <li><b>Test case is a triplet I,S,O</b></li>
    <li><b>Test suit is set of all test cases</b></li>
</ol>
<ol><b>Functional test case /black box designing</b>
    <li>Equivalence Partitioning</li>
    <li>Boundary value analysis</li>
    <li>Cause effect graphing</li>
    <li><b>Error guessing</b></li>
</ol>
</body>
</html>